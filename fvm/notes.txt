
# Overview
This is a simple bytecode interpreter. fvm implements the interpreter, which can easily be added to any application. There is an assembler fvmc.

# Terminology
 - Module: applications are packaged as a module. This is a single file produced by fvmc. It contains:
            - a fixed sized header storing metadata
	    - a symbol table mapping names to addresses
	    - a variable length data segment
	    - a variable length text segment
 - Symbol: a pair of string name and integer address. The address is a location in the virtual address space of the module, pointing either
 into the data or text segments. 
 - Data segment: a fixed sized buffer of initialization data. This will be loaded into the module's data segment of its virtual address space.
 - Text segment: this is the program instructions and any data. It is loaded into the module's text segment and is READ ONLY.
 - Program: modules may be written to implement an RPC program i.e. a set of RPC procedures. Modules written this way can be registered
 with the rpc service to handle incoming RPC calls.
 
# Instructions
There are 8 general purpose 32 bit registers, plus hidden stack pointer (SP) and program counter (PC) registers. SP and PC cannot be directly accessed,
but there are some instructons access them indirectly.

Unusually, it represents integers in network byte order (big endian). This is to make it easy for parsing/encoding XDR structures.

The address space is divided up as follows:
 - 0x0000 - 0x0fff : reserved (currently unused)
 - 0x1000 - 0x4fff : data segment
 - 0x5000 - 0xbfff : text segment
 - 0xc000 - 0xffff : stack

There is space for up to 256 intructions, most are currently unused. So far there are: load, store, jump, push/pop, arithmetic and bitwise operators.

The stack is ephemeral and discarded after the entry point routine exits. The only persistent writable memory is the data segment.

# Cross module calling
It is possible for a module to call into another module using the CALLVIRT instruction. This is implemented essentially as an RPC, with
args and results encoded using XDR, passed on the stack.

# Calling convention
No restrictions are placed on internal subroutine calls. The CALL instruction PUSHes the current PC and then jumps, RET POPs then jumps back.
Typical calling convention would be cdecl:
 - PUSH args in reverse order
 - CALL
 - R0 contains return value
 - SUBSP size of args pushed 


Procedures which are exported i.e. have entries in the symbol table, are expected to be called as entry points. They can be called in two different ways:
called from another module using the CALLVIRT instruction, or as a top level entry point from fvm_run().
When called in either of these ways, the register R0 contains the length of argument data and R1 contains a pointer to the start of the arguments.
The args are on the stack, so R1 = SP - R0.
On return, R0 contains the result length and R1 contains the address of the results. Typically the results will be on the stack but need not be.

Main point to note: all EXPORTed procedures must expect to receive args in R0/R1 and MUST set R0/R1 to results i.e. set to 0 if no results.


# Atypical design
 - Big endian: this is to make it easier to serialize xdr structures
 - Stack grows upwards. again this is to make it easier to encode/decode xdr.
   Entry points receive args on the stack, with SP set to the start of the args i.e. subsequent PUSH operations
   would overwrite the values. But the args can be easily decoded by POPping instructions.

# Clustering
Modules can register with a cluster, so that changes to the data segment are kept synchronized between hosts. This allows
program state to be maintained across different machines. Note that it will be lost if the cluster goes offline.
If the execution of a procedure would result in some side effect e.g. writing to a log file, these side effects are
not clustered, and will happen only on the machine where the procedure was run.

## ------------------------------

fvmc Assembler/Compiler

Programs for fvm may be written either in fvm assembler or a variant of pascal defined below.

fvmc pascal file format:

------------
Program Name(progid,versid,exports...);
Begin

Procedure procname(argname : argtype, var argname : argtype, ...)
Begin
End;

var globalname : type;

End.
------------

Valid Type identifiers: integer, string, opaque, string[len], opaque[len]

Exported procedures MUST always have the following signature:
Procedure exportedproc(argcount : integer, argbuf : opaque, var rescount : integer, var resbuf : opaque);

The difference between parameters declared with var is those with var are passed by reference, those without
are passed by value. So in the above signature, rescount is initally 0 and must be set by the procedure
to the length of the resbuf that must also be set.

There should only be a single Program defined in a compiled module. However, other files may be included
in the compiled module by using a Declare body:

----------

a declare file:

Declare

{ define a procedure to be included }
Procedure Procname(arg : type, ....)
Begin
body....
End;

{ declare a forward reference to a procedure, but don't define its body }
Declare Procedure procname(Arg : type);

End;



---------



Can we make the opcodes more useful for the pascal (?) compiler?
 -> Since we are not doing register allocation it might be better to design with this in mind
 i.e. a stack machine

opcodes:
 load from data segment address
 store into data segment address 
 copy from stack location
 store into stack location
 standard binary operators e.g. plus minus mul sub mod and or xor

Procedure Bob(name : type, var name : type)
Begin
	name = fred;    
	name += x;

End;

We need to design the opcodes with the compiler in mind. Don't even need an assembler, just generate the opcodes directly.
types: i32 u32 i64 u64 string opaque
strings are C strings i.e. null terminated. opaque is just a pointer to somewhere i.e. like C void * pointers.

input parameters are passed on the stack and consumed by the procedure (i.e. caller cleans the stack). Output parameters
are pushed onto the stack after cleaning the input parameters.
Input paramters are pushed from right to left - i.e. leftmost is highest position in stack. This enables variable lenth args.
Output parameters are pushed from left to right - i.e. left most is lowest posisition in stack.

Procedure ProcNull()
Begin
End;

var myi32 : i32;
var myi32array : i32[12];
var mystr : string[64];
var mystrarray : string[8][64];

Procedure LocalProc(bob : i32) : i32
Begin
	Return bob + 1;
End;

Procedure LocalProc2(a : i32, b : string) : i32, string
Begin
	Return a, b;
End;

Procedure ProcEcho(message : string) : i32, string
Begin
	var localvar : i32;
	var localstr : string;
	
	Syscall LogStr(msg);

	myi32array[0] = myi32 + 1;
	localvar = LocalProc(123);
	localvar, localstr = LocalProc2(123,"hello");
	
	Return myi32, msg;
End;

Syscall : make a call into the runtime 
Return : clean stack, push these values onto the stack and return. If procedure falls out at bottom then it is equivalent to an empty Return statement;

Local procedures can be called but must be called with valid variables on left hand side. Return values are removed from stack and stored into these locations.

Opaque args MUST always be followed by a u32 paramter which is interpreted as the opaque length. This is enforced by the compiler.

Geneneral file format:

Program Name(progid,versid,exportedprocs...)
Begin

{ comments like this }
var globalvar : i32;
var anotherglobalvar : string[64];

Procedure ProcNull()
Begin
End;

Procedure ProcEcho(msg : string) : string
Begin
	Return msg; 
End;

Procedure ProcAddOne(val : i32) : i32
Begin
	Return val + 1;
End;

Procedure OpaqueValues(buf : opaque, len : u32) : opaque, u32
Begin
	var p : opaque;
	var i : i32;
	p = buf;
	i = *p;
	p += 4;
	Return p, len - 4;
End;

End.



var x : i32   allocate space on stack i.e. something like push 0
var x : string[64]   allocate space on stack (64 bytes)

Return expr1, exrp2,    adjust stack to remove local vars and args. then evaluate expr1 and push, expr2 and push etc.

Because we are automatically doing xdr encoding/decoding we can keep the internal integer representaiton the same as host so don't
need to do that silly ntohl() everywhere.

Procedures need only be small and simple. It is only intended to be used for simple things mainly glueing together other APIs.

Calling procedures involves the following: given an input arg buffer, decode args according to proc signature. Prepare stack with these values.

Types: i32/u32, i64/u64, string, opaque. Arrays? Lists? i32/u32 are easy - they consume a single slot on the stack. i64/u64 are also easy - they
consume 2 slots on teh stack. So what about strings? We could put the whole string on the stack, then push the starting address. But doing this means we
can't just walk the args decoding and pushing as we go e.g. consider a list of args: u32, string. If we decode the first u32 and push it, then decode the string
and push the address of that we end up with the u32 and string pointer no longer together. So we do it in two passes:
 - go through args and any that are string or opaque get decoded onto the stack, saving their locations.
 - go through args and u32/i32 and u64/i64 are push to stack as normal. string/opaque have their locations pushed instead.

Result (out) variables are also allocated on stack at this point. 
--

Module Name(exported procs); { exported procedures }
Program(progid,versid,exported procs);   { optional, rpc interface }

Begin

Procedure ProcName(a : u32, b : string, out c : u32, out d : opaque)
Begin
	c = a;
	d = &a;
End;

	



End.

;; -------------------------

 - Copy the arg buffer directly onto the stack
 - Go through the args, decoding each and pushing onto the stack.
 - Then go thrgouh args a 2nd time, puhsing pointers for the strings/opaques.

 decode u32/u64 => push value onto stack
 decode string: => copy string onto stack
 decode opaque => copy length + data onto stack

 decode u32 => copy value on stack
 decode u64 => copy high/low onto stack
 decode string => copy address onto stack
 decode opaque => copy length, copy address

 push empty values for the result variables
 -> for u32 push 0
 -> for u64 push 0, 0
 -> for string/opaque push null(0)

Extracting results?
 - walk the output args from left to right, encoding each in turn unset args will be 0 so can be safely ignored.

 - because the output args are just normal variables the procedure simply writes to them as normal.

Procedure ProcName(a : u32, b : string, out c : string)
Begin
	var mystr : string[64];

	{ push "fred", make syscall to LogDebug function }
	Syscall LogDebug("fred");

	c = mystr;
End;


opcodes:
PUSH uint16  ; push constant 
PUSHH uint16 ; pop, push (uint16 << 16) | (popped value & 0xffff);
DROP uint16  ; drop uint16 number of cells from stack
ALLOC uint16 ; allocate uint16 cells on stack
LD uint16    ; load from address onto top of stack
ST uint16    ; store top of stack into this address
JMP uint16   ; jmp to address
JZ, JN, JP, JNZ, JPN, JPZ ; conditional jumps
RET          ; return
INC uint16   ; increment value at stack depth 


; standard operators 
ADD
SUB
MUL
DIV
MOD
MUL
SHL
SHR
NOT
AND
OR
XOR


